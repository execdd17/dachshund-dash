<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dachshund Dash!</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #f7f7f7;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Courier New', monospace;
    padding: 20px 0;
  }
  h1 {
    font-size: 28px;
    color: #535353;
    margin-bottom: 12px;
    letter-spacing: 2px;
  }
  canvas {
    border: 2px solid #4a8f3f;
    background: #87CEEB;
    image-rendering: auto;  /* sprites scale smoothly; obstacles stay crisp */
    max-width: 100%;
    height: auto;
  }
  .hint {
    margin-top: 10px;
    color: #999;
    font-size: 14px;
  }
  .game-wrapper {
    position: relative;
  }
  #nameEntryOverlay {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 12px;
    font-family: 'Courier New', monospace;
    z-index: 10;
  }
  #nameEntryOverlay.visible {
    display: flex;
  }
  #nameEntryOverlay .prompt {
    color: #fff;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    padding: 0 20px;
  }
  #nameEntryOverlay input {
    font-family: 'Courier New', monospace;
    font-size: 18px;
    padding: 8px 12px;
    max-width: 200px;
    border: 2px solid #4a8f3f;
    border-radius: 4px;
    background: rgba(255,255,255,0.95);
  }
  #nameEntryOverlay button {
    font-family: 'Courier New', monospace;
    font-size: 16px;
    padding: 8px 24px;
    background: #4a8f3f;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  #nameEntryOverlay button:hover {
    background: #5a9f4f;
  }

  /* --- Global Leaderboard --- */
  #globalLeaderboard {
    width: 100%;
    max-width: 800px;
    margin-top: 24px;
    padding: 16px 24px;
    color: #535353;
  }
  #globalLeaderboard h2 {
    font-size: 16px;
    letter-spacing: 2px;
    color: #535353;
    text-align: center;
    margin-bottom: 12px;
  }
  #globalLeaderboard .lb-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    gap: 12px;
  }
  #globalLeaderboard .lb-search {
    font-family: 'Courier New', monospace;
    font-size: 13px;
    padding: 4px 8px;
    background: #fff;
    color: #535353;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 180px;
  }
  #globalLeaderboard .lb-search::placeholder {
    color: #aaa;
  }
  #globalLeaderboard .lb-search:focus {
    outline: none;
    border-color: #999;
  }
  #globalLeaderboard .lb-page-info {
    font-size: 12px;
    color: #999;
  }
  #globalLeaderboard table {
    width: 100%;
    border-collapse: collapse;
  }
  #globalLeaderboard thead th {
    font-size: 12px;
    color: #999;
    text-align: left;
    padding: 4px 8px;
    border-bottom: 1px solid #ddd;
    font-weight: normal;
    text-transform: uppercase;
  }
  #globalLeaderboard thead th:first-child {
    width: 50px;
    text-align: center;
  }
  #globalLeaderboard thead th:last-child {
    text-align: right;
  }
  #globalLeaderboard tbody td {
    font-size: 14px;
    padding: 5px 8px;
    border-bottom: 1px solid #eee;
  }
  #globalLeaderboard tbody td:first-child {
    text-align: center;
    color: #999;
  }
  #globalLeaderboard tbody td:last-child {
    text-align: right;
  }
  #globalLeaderboard tbody .lb-empty {
    text-align: center;
    color: #aaa;
    padding: 20px;
  }
  #globalLeaderboard .lb-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
    margin-top: 8px;
  }
  #globalLeaderboard .lb-pagination button {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    padding: 3px 12px;
    background: #fff;
    color: #535353;
    border: 1px solid #ccc;
    border-radius: 3px;
    cursor: pointer;
  }
  #globalLeaderboard .lb-pagination button:hover:not(:disabled) {
    background: #eee;
  }
  #globalLeaderboard .lb-pagination button:disabled {
    color: #ccc;
    border-color: #ddd;
    cursor: default;
  }
  #globalLeaderboard .lb-status {
    text-align: center;
    color: #aaa;
    font-size: 13px;
    padding: 16px;
  }
</style>
<!-- Firebase SDK (compat builds for no-build-step usage) -->
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
</head>
<body>
<h1>DACHSHUND DASH</h1>
<div class="game-wrapper">
  <canvas id="game" width="1600" height="500"></canvas>
  <div id="nameEntryOverlay">
    <span class="prompt">New high score! Enter your name:</span>
    <input type="text" id="nameInput" maxlength="12" placeholder="Your name" />
    <button type="button" id="nameSubmitBtn">Submit</button>
  </div>
</div>
<p class="hint">SPACE / UP to jump (tap twice to double jump!) &mdash; DOWN / S to duck</p>
<div id="globalLeaderboard">
  <h2>GLOBAL LEADERBOARD</h2>
  <div class="lb-controls">
    <input type="text" class="lb-search" id="lbSearch" placeholder="Search by name..." maxlength="12" />
    <span class="lb-page-info" id="lbPageInfo"></span>
  </div>
  <table>
    <thead>
      <tr><th>#</th><th>NAME</th><th>SCORE</th></tr>
    </thead>
    <tbody id="lbBody"></tbody>
  </table>
  <div class="lb-pagination">
    <button id="lbPrev" disabled>&lt; PREV</button>
    <button id="lbNext" disabled>NEXT &gt;</button>
  </div>
</div>
<script>
// --- Firebase setup ---
const firebaseConfig = {
  apiKey: "AIzaSyA_fHbRyoebo-g54Mn9T_BVIStNxNS8hJ4",
  authDomain: "dachshund-dash-b835a.firebaseapp.com",
  projectId: "dachshund-dash-b835a",
  storageBucket: "dachshund-dash-b835a.firebasestorage.app",
  messagingSenderId: "41936067257",
  appId: "1:41936067257:web:bebc6d4a5a8df272555968"
};

let db = null;
let firebaseReady = false;
try {
  if (typeof firebase !== 'undefined' && firebase.initializeApp) {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    firebaseReady = true;
  }
} catch (e) {
  console.warn('Firebase init failed, global leaderboard disabled:', e);
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Logical size (before 2x scale) ---
const W = 800;
const H = 250;

// --- Constants ---
const GROUND_Y = 200;
const GRAVITY = 0.5;
const JUMP_FORCE = -11;
const DOUBLE_JUMP_FORCE = -7;
const INITIAL_SPEED = 2.35;
const MAX_SPEED = 20;
const SPEED_INCREMENT = 0.001;
const MIN_OBSTACLE_GAP = 300;
const MAX_OBSTACLE_GAP = 500;

// --- Chase mode ---
const CHASE_FIRST_AT = 200;
const CHASE_COOLDOWN = 300;
const CHASE_DURATION_FRAMES = 16 * 60;  // 16 seconds at 60fps
const SQUIRREL_OFFSET = 580;

// --- Boss chase ---
const BOSS_MILESTONE = 1000;
const DOG_BASE_X = 60;                      // dog's normal resting x position
const BOSS_MAX_DOG_SHIFT = 150;             // max rightward shift during boss (px)
const BOSS_DOG_SHIFT_SPEED = 0.75;          // px/frame ramp-up when chasing (~3.3s to max)
const BOSS_DOG_RETURN_SPEED = 1.5;          // px/frame ramp-down when losing (~1.7s to return)
const BOSS_SQUIRREL_START_X = -20;
const BOSS_SQUIRREL_LOSE_SPEED = 3.0;       // px/frame when losing (retreating left)
const BOSS_CHASE_DURATION = 1600;           // frames total (~26.7s): fixed duration regardless of speed
const BOSS_SPEED_MULTIPLIER = 1.25;         // max speed multiplier during boss
const BOSS_OBSTACLE_GAP_MULTIPLIER = 1.5;   // fewer obstacles (larger gaps)

// --- Giant mode ---
const GIANT_FIRST_AT = 500;                  // golden hot dog can't appear before this score
const GIANT_COOLDOWN = 600;                  // minimum score between golden hot dog spawns
const GIANT_SPAWN_CHANCE = 0.03;             // 3% chance per obstacle spawn cycle when eligible
const GIANT_DURATION = 15000;                // ms (15 seconds — matches giant music track)
const GIANT_WARN_AT = 2500;                  // ms remaining before flashing warning
const GIANT_SCALE = 2.0;                     // visual scale multiplier for the dog
const GIANT_SCALE_TRANSITION = 500;          // ms for grow/shrink animation
const GIANT_SCORE_MULTIPLIER = 2;            // score multiplier while giant
const GIANT_EAT_BONUS = 25;                  // bonus points per obstacle eaten
const GIANT_BONK_BONUS = 15;                 // bonus points per frisbee bonked

// --- Game state ---
let gameState = 'idle'; // idle, running, dead, enteringName
let score = 0;
let highScore = 0;
let speed = INITIAL_SPEED;
let frameCount = 0;
let lastMilestone = 0;
let deathTime = 0;
let pendingScore = null;
let slowMode = false;

// --- Landing dust particles ---
let landingParticles = [];

// --- Giant mode state ---
let giantActive = false;
let giantStartTime = 0;
let giantGrowing = false;
let giantShrinking = false;
let giantTransitionStart = 0;
let giantScoreMultiplier = 1;
let lastGoldenSpawnScore = 0;
let giantChompEffects = [];   // [{x, y, startTime}]
let giantBonkEffects = [];    // [{x, y, vx, vy, rotation, rotSpeed, startTime}]

// --- High scores (localStorage) ---
const HIGH_SCORES_KEY = 'dachshundDashHighScores';
const MAX_HIGH_SCORES = 5;
let highScores = [];

// --- Global high scores (Firebase) ---
const GLOBAL_MAX_SCORES = 100;
const GLOBAL_PAGE_SIZE = 10;
let globalHighScores = [];
let globalScoresLoaded = false;
let globalScoresError = false;
let globalScoresCached = [];
let lastGlobalFetchTime = 0;
const GLOBAL_FETCH_INTERVAL = 30000;
let lbPage = 0;
let lbSearchTerm = '';

function loadHighScores() {
  try {
    const raw = localStorage.getItem(HIGH_SCORES_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(e => e && typeof e.name === 'string' && typeof e.score === 'number').slice(0, MAX_HIGH_SCORES);
  } catch {
    return [];
  }
}

function saveHighScores(scores) {
  try {
    localStorage.setItem(HIGH_SCORES_KEY, JSON.stringify(scores));
  } catch (_) {}
}

function addToHighScores(name, scoreVal) {
  const n = (name || '').trim() || 'Player';
  const displayName = n.slice(0, 12).toUpperCase();
  const next = [...highScores, { name: displayName, score: scoreVal }]
    .sort((a, b) => b.score - a.score)
    .slice(0, MAX_HIGH_SCORES);
  highScores = next;
  saveHighScores(highScores);
  highScore = highScores[0]?.score ?? 0;
  submitGlobalScore(displayName, scoreVal);
  return highScores;
}

// --- Global score functions (Firebase) ---
function computeScoreChecksum(name, scoreVal, timestamp) {
  const salt = 'dachshund-dash-2024-pepper';
  const raw = salt + '|' + name + '|' + scoreVal + '|' + timestamp;
  let hash = 5381;
  for (let i = 0; i < raw.length; i++) {
    hash = ((hash << 5) + hash + raw.charCodeAt(i)) & 0xFFFFFFFF;
  }
  return hash.toString(36);
}

async function fetchGlobalScores() {
  if (!firebaseReady || !db) {
    globalScoresError = true;
    renderHtmlLeaderboard();
    return;
  }
  try {
    const snapshot = await db.collection('scores')
      .orderBy('score', 'desc')
      .orderBy('timestamp', 'asc')
      .limit(GLOBAL_MAX_SCORES)
      .get();
    globalHighScores = snapshot.docs.map(doc => {
      const d = doc.data();
      return { name: d.name, score: d.score };
    });
    globalScoresCached = [...globalHighScores];
    globalScoresLoaded = true;
    globalScoresError = false;
  } catch (e) {
    console.warn('Failed to fetch global scores:', e);
    globalScoresError = true;
    if (globalScoresCached.length > 0) {
      globalHighScores = [...globalScoresCached];
      globalScoresLoaded = true;
    }
  }
  renderHtmlLeaderboard();
}

function getFilteredScores() {
  const withRank = globalHighScores.map((e, i) => ({ ...e, rank: i + 1 }));
  if (!lbSearchTerm) return withRank;
  const term = lbSearchTerm.toUpperCase();
  return withRank.filter(e => e.name.includes(term));
}

function renderHtmlLeaderboard() {
  const body = document.getElementById('lbBody');
  const pageInfo = document.getElementById('lbPageInfo');
  const prevBtn = document.getElementById('lbPrev');
  const nextBtn = document.getElementById('lbNext');
  if (!body) return;

  if (!globalScoresLoaded && !globalScoresError) {
    body.innerHTML = '<tr><td colspan="3" class="lb-status">Loading...</td></tr>';
    pageInfo.textContent = '';
    prevBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  if (globalScoresError && globalHighScores.length === 0) {
    body.innerHTML = '<tr><td colspan="3" class="lb-status">Leaderboard unavailable (offline)</td></tr>';
    pageInfo.textContent = '';
    prevBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  const filtered = getFilteredScores();
  const totalPages = Math.max(1, Math.ceil(filtered.length / GLOBAL_PAGE_SIZE));
  if (lbPage >= totalPages) lbPage = totalPages - 1;
  if (lbPage < 0) lbPage = 0;

  const start = lbPage * GLOBAL_PAGE_SIZE;
  const pageScores = filtered.slice(start, start + GLOBAL_PAGE_SIZE);

  if (filtered.length === 0) {
    body.innerHTML = lbSearchTerm
      ? '<tr><td colspan="3" class="lb-empty">No matching scores</td></tr>'
      : '<tr><td colspan="3" class="lb-empty">No scores yet — be the first!</td></tr>';
    pageInfo.textContent = '';
    prevBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  body.innerHTML = pageScores.map(entry => {
    const name = entry.name.replace(/</g, '&lt;');
    const score = String(Math.floor(entry.score)).padStart(5, '0');
    return `<tr><td>${entry.rank}</td><td>${name}</td><td>${score}</td></tr>`;
  }).join('');

  pageInfo.textContent = `Page ${lbPage + 1} of ${totalPages}`;
  prevBtn.disabled = lbPage === 0;
  nextBtn.disabled = lbPage >= totalPages - 1;
}

async function submitGlobalScore(name, scoreVal) {
  if (!firebaseReady || !db) return;
  const timestamp = Date.now();
  const checksum = computeScoreChecksum(name, scoreVal, timestamp);
  try {
    await db.collection('scores').add({
      name: name,
      score: scoreVal,
      timestamp: timestamp,
      checksum: checksum
    });
    await fetchGlobalScores();
  } catch (e) {
    console.warn('Failed to submit global score:', e);
  }
}

// --- Dachshund ---
const dog = {
  x: 60,
  y: GROUND_Y,
  width: 100,
  height: 30,
  vy: 0,
  jumping: false,
  doubleJumped: false,
  ducking: false,
  legFrame: 0,
};

// --- Dog sprite animation (PNG from png/dachshund) ---
const DOG_SPRITE_FPS = 12;   // 10-14 range: lower = choppier, higher = smoother
const DOG_SPRITE_SCALE = 70 / 512;   // dachshund_run_* are 512x1024
const DOG_SPRITE_ANCHOR = 0.5;       // bottom-center: 0.5 = center X
const DOG_SPRITE_GROUND_OFFSET = 85; // sprite has padding below feet; shift down so feet land on ground
const dogSprites = { idle: [], run: [], jump: [], slide: [], fall: [], dead: [], doublejump: [], bite: [] };
let dogSpritesReady = false;

function loadDogSprites() {
  const runPaths = ['png/dachshund/dachshund_run_00.png', 'png/dachshund/dachshund_run_01.png', 'png/dachshund/dachshund_run_02.png'];
  const pancakePaths = ['png/dachshund/dachshund_pancake_00.png', 'png/dachshund/dachshund_pancake_01.png', 'png/dachshund/dachshund_pancake_02.png'];
  const jumpPaths = ['png/dachshund/dachshund_jump_00.png', 'png/dachshund/dachshund_jump_01.png', 'png/dachshund/dachshund_jump_02.png'];
  const doublejumpPaths = ['png/dachshund/dachshund_flip_00.png', 'png/dachshund/dachshund_flip_01.png', 'png/dachshund/dachshund_flip_02.png'];
  let pending = runPaths.length + pancakePaths.length + jumpPaths.length + doublejumpPaths.length + 1; // +1 for bite sheet
  const onLoad = () => { pending--; if (pending === 0) dogSpritesReady = true; };
  runPaths.forEach((path, i) => {
    const img = new Image();
    img.onload = img.onerror = onLoad;
    img.src = path;
    dogSprites.run[i] = img;
  });
  pancakePaths.forEach((path, i) => {
    const img = new Image();
    img.onload = img.onerror = onLoad;
    img.src = path;
    dogSprites.slide[i] = img;
  });
  jumpPaths.forEach((path, i) => {
    const img = new Image();
    img.onload = img.onerror = onLoad;
    img.src = path;
    dogSprites.jump[i] = img;
  });
  doublejumpPaths.forEach((path, i) => {
    const img = new Image();
    img.onload = img.onerror = onLoad;
    img.src = path;
    dogSprites.doublejump[i] = img;
  });
  dogSprites.idle = dogSprites.run.slice(0, 1);
  dogSprites.dead = dogSprites.run.slice(0, 1);
  // Bite sprite sheet (3 horizontal frames in one image)
  const biteSheet = new Image();
  biteSheet.onload = biteSheet.onerror = onLoad;
  biteSheet.src = 'png/dachshund/bite_3_image_sequence.png';
  dogSprites.bite = [biteSheet];
}
loadDogSprites();

// --- Squirrel sprite animation (PNG from png/squirrel) ---
const SQUIRREL_SPRITE_FPS = 12;
const SQUIRREL_SPRITE_SCALE = 50 / 512;   // squirrel_run_* are 512x1024
const SQUIRREL_SPRITE_ANCHOR = 0.5;       // bottom-center
const SQUIRREL_SPRITE_GROUND_OFFSET = 60; // sprite padding; lower = squirrel higher on ground
const squirrelSprites = { run: [] };
let squirrelSpritesReady = false;

function loadSquirrelSprites() {
  const runPaths = ['png/squirrel/squirrel_run_00.png', 'png/squirrel/squirrel_run_01.png', 'png/squirrel/squirrel_run_02.png'];
  let pending = runPaths.length;
  const onLoad = () => { pending--; if (pending === 0) squirrelSpritesReady = true; };
  runPaths.forEach((path, i) => {
    const img = new Image();
    img.onload = img.onerror = onLoad;
    img.src = path;
    squirrelSprites.run[i] = img;
  });
}
loadSquirrelSprites();

let squirrelSpriteFrame = 0;
let squirrelSpriteLastAdvance = performance.now();

function advanceSquirrelSpriteFrame() {
  const now = performance.now();
  const frameDuration = 1000 / SQUIRREL_SPRITE_FPS;
  if (now - squirrelSpriteLastAdvance >= frameDuration) {
    squirrelSpriteLastAdvance = now;
    const frames = squirrelSprites.run;
    if (frames && frames.length > 0) {
      squirrelSpriteFrame = (squirrelSpriteFrame + 1) % frames.length;
    }
  }
}

let dogSpriteAnim = 'idle';
let dogSpriteFrame = 0;
let dogSpriteLastAdvance = performance.now();

function getDogSpriteAnim() {
  if (gameState === 'dead' || gameState === 'enteringName') return 'dead';
  if (giantActive && giantChompEffects.length > 0 && performance.now() - giantChompEffects[giantChompEffects.length - 1].startTime < 250) return 'bite';
  if (dog.ducking) return 'slide';
  if (dog.jumping) return dog.doubleJumped ? 'doublejump' : 'jump';
  if (gameState === 'idle') return 'idle';
  return 'run';
}

function getDogJumpFrameIndex() {
  if (dog.vy < 0) return 0;
  if (dog.y >= GROUND_Y - 25) return 2;
  return 1;
}

function advanceDogSpriteFrame() {
  const now = performance.now();
  const frameDuration = 1000 / DOG_SPRITE_FPS;
  if (now - dogSpriteLastAdvance >= frameDuration) {
    dogSpriteLastAdvance = now;
    const anim = getDogSpriteAnim();
    if (anim !== dogSpriteAnim) {
      dogSpriteAnim = anim;
      dogSpriteFrame = 0;
    } else {
      if (dogSpriteAnim === 'bite') {
        dogSpriteFrame = Math.min(dogSpriteFrame + 1, 2); // cap at 3 frames, hold last
      } else {
        const frames = dogSprites[dogSpriteAnim];
        if (frames && frames.length > 0) {
          dogSpriteFrame = (dogSpriteFrame + 1) % frames.length;  // loop
        }
      }
    }
  }
}

// --- Obstacles (hot dogs & frisbees) ---
let obstacles = [];
let nextObstacleIn = 100;
let lastObstacleType = 'hotdog';

// --- Chase mode state ---
let chaseActive = false;
let chasePending = false;  // waiting for obstacles to clear before chase starts
let chaseEntering = false; // squirrel running in from right when chase starts
let chaseEscaping = false;  // squirrel running off-screen after chase ends
let chaseStartedFrame = 0;
let lastChaseEndScore = 0;
let squirrelEnterX = 0;
let squirrelEnterSpeed = 1.5;
let squirrelEscapeX = 0;
let squirrelEscapeSpeed = 1.5;

// --- Boss chase state ---
let bossPending = false;
let bossChasing = false;
let bossLosing = false;
let lastBossMilestone = 0;
let bossSquirrelX = BOSS_SQUIRREL_START_X;
let bossChaseFrames = 0;
let bossDogShift = 0;

// --- Music (WAV-based) ---
let musicOn = true;
let musicStarted = false;
const musicNormal = new Audio('sound/who_let_the_dogs_out_soul_version.wav');
musicNormal.loop = true;
musicNormal.volume = 0.30;
const musicGiant = new Audio('sound/who_let_the_dogs_out_edm_short.mp3');
musicGiant.loop = true;
musicGiant.volume = 0.25;

// Browsers block autoplay — start music on first user interaction
function startMusicOnInteraction() {
  if (musicStarted) return;
  musicStarted = true;
  if (musicOn) {
    getActiveMusic().play().catch(() => {});
  }
  document.removeEventListener('click', startMusicOnInteraction);
  document.removeEventListener('keydown', startMusicOnInteraction);
  document.removeEventListener('touchstart', startMusicOnInteraction);
}
document.addEventListener('click', startMusicOnInteraction);
document.addEventListener('keydown', startMusicOnInteraction);
document.addEventListener('touchstart', startMusicOnInteraction);

// --- Ground decoration ---
let groundOffset = 0;

// --- Cloud decoration ---
let clouds = [
  { x: 100, y: 40, size: 1.0 },
  { x: 350, y: 25, size: 1.3 },
  { x: 600, y: 50, size: 0.8 },
  { x: 200, y: 60, size: 0.6 },
  { x: 750, y: 35, size: 1.1 },
];

// --- Flowers ---
let flowers = [];
for (let i = 0; i < 12; i++) {
  flowers.push({
    x: Math.random() * W,
    baseY: GROUND_Y + 22 + Math.random() * 8,
    size: 3 + Math.random() * 3,
    color: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4'][Math.floor(Math.random() * 4)],
  });
}

// --- Rolling hills / mountain parallax layers ---
// Smooth rolling hills (mid/near layers)
function hillY(x, offset, amp, freq) {
  const v = x + offset;
  return amp * (
    Math.sin(v * freq) * 0.50 +
    Math.sin(v * freq * 2.1 + 1.3) * 0.30 +
    Math.sin(v * freq * 0.6 + 0.8) * 0.20
  );
}
// Mountain range (far layer) — layered abs(sin) with pow sharpening
function mountainY(x, offset, amp, freq) {
  const v = x + offset;
  // Broad mountain masses
  const base = Math.abs(Math.sin(v * freq * 0.45 + 0.8)) * 0.25;
  // Main peaks — pow < 1 sharpens the tips
  const peaks = Math.pow(Math.abs(Math.sin(v * freq * 1.1)), 0.7) * 0.30;
  // Secondary ridges
  const ridges = Math.abs(Math.sin(v * freq * 2.3 + 1.5)) * 0.20;
  // Fine jagged detail
  const jag = Math.abs(Math.sin(v * freq * 4.7 + 3.2)) * 0.15;
  // Subtle craggy texture
  const crag = Math.abs(Math.sin(v * freq * 8.3 + 5.1)) * 0.10;
  return amp * (base + peaks + ridges + jag + crag);
}

// --- Sound effects (Web Audio API, no files needed) ---
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

// Preload chomp.wav as an AudioBuffer
let chompBuffer = null;
fetch('sound/chomp.mp3')
  .then(r => r.arrayBuffer())
  .then(buf => {
    const a = getAudioCtx();
    return a.decodeAudioData(buf);
  })
  .then(decoded => { chompBuffer = decoded; })
  .catch(() => {});

function playJumpSound() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  // Quick upward pitch sweep — a little "boing"
  osc.frequency.setValueAtTime(280, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(560, ctx.currentTime + 0.1);
  gain.gain.setValueAtTime(0.15, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.15);
}

function playScoreSound() {
  const ctx = getAudioCtx();
  // Two-note chime
  [520, 680].forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.1);
    gain.gain.setValueAtTime(0.12, ctx.currentTime + i * 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.2);
    osc.start(ctx.currentTime + i * 0.1);
    osc.stop(ctx.currentTime + i * 0.1 + 0.2);
  });
}

function playDeathSound() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'square';
  // Descending sad tone
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(120, ctx.currentTime + 0.4);
  gain.gain.setValueAtTime(0.1, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.4);
}

function playDoubleJumpSound() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  // Higher pitched boing
  osc.frequency.setValueAtTime(440, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.08);
  gain.gain.setValueAtTime(0.13, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.12);
}

function playDuckSound() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  // Quick downward "whoosh"
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.08);
  gain.gain.setValueAtTime(0.1, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.1);
}

function playCrunchSound() {
  if (!chompBuffer) return;
  const a = getAudioCtx();
  const source = a.createBufferSource();
  source.buffer = chompBuffer;
  const gain = a.createGain();
  gain.gain.value = 0.4;
  source.connect(gain);
  gain.connect(a.destination);
  source.start(a.currentTime);
}

function playBonkSound() {
  const a = getAudioCtx();
  // Hollow metallic "bonk"
  const osc = a.createOscillator();
  const gain = a.createGain();
  osc.connect(gain);
  gain.connect(a.destination);
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(800, a.currentTime);
  osc.frequency.exponentialRampToValueAtTime(200, a.currentTime + 0.15);
  gain.gain.setValueAtTime(0.18, a.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, a.currentTime + 0.2);
  osc.start(a.currentTime);
  osc.stop(a.currentTime + 0.2);
  // Secondary harmonic
  const osc2 = a.createOscillator();
  const gain2 = a.createGain();
  osc2.connect(gain2);
  gain2.connect(a.destination);
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(1200, a.currentTime);
  osc2.frequency.exponentialRampToValueAtTime(400, a.currentTime + 0.1);
  gain2.gain.setValueAtTime(0.08, a.currentTime);
  gain2.gain.exponentialRampToValueAtTime(0.001, a.currentTime + 0.12);
  osc2.start(a.currentTime);
  osc2.stop(a.currentTime + 0.12);
}

function playGiantActivateSound() {
  const a = getAudioCtx();
  // Ascending power-up fanfare
  [330, 440, 660].forEach((freq, i) => {
    const osc = a.createOscillator();
    const gain = a.createGain();
    osc.connect(gain);
    gain.connect(a.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, a.currentTime + i * 0.08);
    gain.gain.setValueAtTime(0.1, a.currentTime + i * 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, a.currentTime + i * 0.08 + 0.15);
    osc.start(a.currentTime + i * 0.08);
    osc.stop(a.currentTime + i * 0.08 + 0.15);
  });
}

function playGiantDeactivateSound() {
  const a = getAudioCtx();
  // Descending three tones
  [660, 440, 330].forEach((freq, i) => {
    const osc = a.createOscillator();
    const gain = a.createGain();
    osc.connect(gain);
    gain.connect(a.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, a.currentTime + i * 0.08);
    gain.gain.setValueAtTime(0.08, a.currentTime + i * 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, a.currentTime + i * 0.08 + 0.12);
    osc.start(a.currentTime + i * 0.08);
    osc.stop(a.currentTime + i * 0.08 + 0.12);
  });
}

function getActiveMusic() {
  return giantMusicActive ? musicGiant : musicNormal;
}

function toggleMusic() {
  if (musicOn) {
    musicOn = false;
    musicNormal.pause();
    musicGiant.pause();
  } else {
    musicOn = true;
    getActiveMusic().play().catch(() => {});
  }
}

// ============================================================
//  TIME-OF-DAY CYCLE (repeats every 620 pts)
//  Day 0-250, sunset 250-310 (~7.5 sec), night 310-560 (250 pts),
//  dawn 560-620 (~7.5 sec), then repeat
// ============================================================

function lerpColor(hex1, hex2, t) {
  const parse = (hex) => {
    const h = hex.replace('#', '');
    return [
      parseInt(h.slice(0, 2), 16) / 255,
      parseInt(h.slice(2, 4), 16) / 255,
      parseInt(h.slice(4, 6), 16) / 255,
    ];
  };
  const [r1, g1, b1] = parse(hex1);
  const [r2, g2, b2] = parse(hex2);
  const r = Math.round((r1 + (r2 - r1) * t) * 255);
  const g = Math.round((g1 + (g2 - g1) * t) * 255);
  const b = Math.round((b1 + (b2 - b1) * t) * 255);
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function getTimeOfDay() {
  const CYCLE = 620;
  const s = score % CYCLE;
  const DAY_END = 250;
  const SUNSET_END = 310;   // 60 pts: day→night (50% longer)
  const NIGHT_END = 560;    // 250 pts after night begins
  const DAWN_END = 620;     // 60 pts: night→day
  let phase, stage, t;
  if (s < DAY_END) {
    stage = 'day';
    phase = 0;
    t = s / DAY_END;
  } else if (s < SUNSET_END) {
    stage = 'sunset';
    phase = (s - DAY_END) / (SUNSET_END - DAY_END) * 0.5;  // 0→0.5 = full night at 290
    t = (s - DAY_END) / (SUNSET_END - DAY_END);
  } else if (s < NIGHT_END) {
    stage = 'night';
    phase = 0.5;
    t = (s - SUNSET_END) / (NIGHT_END - SUNSET_END);
  } else {
    stage = 'dawn';
    phase = 0.5 + (s - NIGHT_END) / (DAWN_END - NIGHT_END) * 0.5;  // 0.5→1 = day at 580
    t = (s - NIGHT_END) / (DAWN_END - NIGHT_END);
  }
  return { phase, stage, t };
}

// ============================================================
//  DRAWING: DACHSHUND (PNG sprites only)
// ============================================================

function drawDachshundSprite(x, y) {
  const anim = getDogSpriteAnim();

  // Bite animation: 3-frame horizontal sprite sheet, source-rect slicing
  if (anim === 'bite' && dogSprites.bite && dogSprites.bite[0]) {
    const sheet = dogSprites.bite[0];
    if (!sheet.complete || !sheet.naturalWidth) return false;
    const frameW = 512;
    const frameH = 1024;
    const frameIdx = dogSpriteFrame % 3;
    const sx = frameIdx * frameW;
    const dw = frameW * DOG_SPRITE_SCALE;
    const dh = frameH * DOG_SPRITE_SCALE;
    const anchorX = dog.width * DOG_SPRITE_ANCHOR;
    const dx = x + anchorX - dw / 2;
    const dy = y - dh + DOG_SPRITE_GROUND_OFFSET;
    ctx.drawImage(sheet, sx, 0, frameW, frameH, dx, dy, dw, dh);
    return true;
  }

  const frames = dogSprites[anim];
  const frameIdx = (anim === 'jump' || anim === 'doublejump') ? getDogJumpFrameIndex() : (dogSpriteFrame % (frames?.length || 1));
  const img = (anim === 'doublejump' && frameIdx === 2)
    ? (dogSprites.jump[2])
    : (frames && frames[frameIdx]);
  if (!img || !img.complete || !img.naturalWidth) return false;
  const sw = img.naturalWidth;
  const sh = img.naturalHeight;
  const dw = sw * DOG_SPRITE_SCALE;
  const dh = sh * DOG_SPRITE_SCALE;
  const anchorX = dog.width * DOG_SPRITE_ANCHOR;
  const dx = x + anchorX - dw / 2;
  const dy = y - dh + DOG_SPRITE_GROUND_OFFSET;
  ctx.drawImage(img, 0, 0, sw, sh, dx, dy, dw, dh);
  return true;
}

function drawDachshund(x, y, legFrame) {
  if (dogSpritesReady) drawDachshundSprite(x, y);
}

function drawHotDog(x, y) {
  const hw = 36;
  const hh = 22;
  const mid = hh / 2;

  // --- Dark outline (drawn first, slightly larger) ---
  ctx.strokeStyle = '#5C3A1E';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Outline: full bun silhouette
  ctx.beginPath();
  ctx.moveTo(x + 10, y + 1);
  ctx.quadraticCurveTo(x + hw / 2, y - 1, x + hw - 10, y + 1);
  ctx.quadraticCurveTo(x + hw - 4, y + 1, x + hw - 2, y + 5);
  ctx.quadraticCurveTo(x + hw + 1, y + mid, x + hw + 1, y + mid + 4);
  ctx.quadraticCurveTo(x + hw + 1, y + hh + 1, x + hw - 7, y + hh + 1);
  ctx.lineTo(x + 7, y + hh + 1);
  ctx.quadraticCurveTo(x - 1, y + hh + 1, x - 1, y + mid + 4);
  ctx.quadraticCurveTo(x - 1, y + mid, x + 2, y + 5);
  ctx.quadraticCurveTo(x + 4, y + 1, x + 10, y + 1);
  ctx.stroke();

  // --- Bun bottom half ---
  ctx.fillStyle = '#D4951A';
  ctx.beginPath();
  ctx.moveTo(x + 5, y + mid + 1);
  ctx.lineTo(x + hw - 5, y + mid + 1);
  ctx.quadraticCurveTo(x + hw, y + mid + 1, x + hw, y + mid + 4);
  ctx.quadraticCurveTo(x + hw, y + hh, x + hw - 7, y + hh);
  ctx.lineTo(x + 7, y + hh);
  ctx.quadraticCurveTo(x, y + hh, x, y + mid + 4);
  ctx.quadraticCurveTo(x, y + mid + 1, x + 5, y + mid + 1);
  ctx.fill();

  // Bottom bun shadow
  ctx.fillStyle = '#B8800F';
  ctx.beginPath();
  ctx.moveTo(x + 7, y + hh - 3);
  ctx.quadraticCurveTo(x + hw / 2, y + hh, x + hw - 7, y + hh - 3);
  ctx.lineTo(x + hw - 7, y + hh);
  ctx.quadraticCurveTo(x + hw / 2, y + hh + 1, x + 7, y + hh);
  ctx.closePath();
  ctx.fill();

  // --- Sausage (pokes out both ends!) ---
  ctx.fillStyle = '#D94438';
  roundRect(x - 4, y + 6, hw + 8, 12, 6);

  // Sausage highlight (shiny top)
  ctx.fillStyle = '#EF6B5E';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2, y + 9, hw / 2 - 2, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Sausage dark ends
  ctx.fillStyle = '#A42A1C';
  ctx.beginPath();
  ctx.arc(x - 2, y + 12, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + hw + 2, y + 12, 5, 0, Math.PI * 2);
  ctx.fill();

  // Sausage end highlights
  ctx.fillStyle = '#D94438';
  ctx.beginPath();
  ctx.arc(x - 1, y + 11, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + hw + 3, y + 11, 2.5, 0, Math.PI * 2);
  ctx.fill();

  // --- Bun top half ---
  ctx.fillStyle = '#DBA328';
  ctx.beginPath();
  ctx.moveTo(x + 5, y + mid + 1);
  ctx.lineTo(x + hw - 5, y + mid + 1);
  ctx.quadraticCurveTo(x + hw - 2, y + mid, x + hw - 3, y + 5);
  ctx.quadraticCurveTo(x + hw - 5, y + 1, x + hw - 9, y + 1);
  ctx.lineTo(x + 9, y + 1);
  ctx.quadraticCurveTo(x + 5, y + 1, x + 3, y + 5);
  ctx.quadraticCurveTo(x + 2, y + mid, x + 5, y + mid + 1);
  ctx.fill();

  // Bun top crust highlight
  ctx.fillStyle = '#EDBE45';
  ctx.beginPath();
  ctx.moveTo(x + 11, y + 3);
  ctx.quadraticCurveTo(x + hw / 2, y, x + hw - 11, y + 3);
  ctx.lineTo(x + hw - 11, y + 6);
  ctx.quadraticCurveTo(x + hw / 2, y + 3, x + 11, y + 6);
  ctx.closePath();
  ctx.fill();

  // --- Bun seam (dark line where bun splits open) ---
  ctx.strokeStyle = '#8B6914';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x + 3, y + mid);
  ctx.quadraticCurveTo(x + hw / 2, y + mid - 1, x + hw - 3, y + mid);
  ctx.stroke();

  // --- Sesame seeds on top ---
  ctx.fillStyle = '#FFF5D6';
  const seeds = [[x + 9, y + 4], [x + 16, y + 2.5], [x + 24, y + 3.5], [x + hw - 9, y + 4.5]];
  seeds.forEach(([sx, sy]) => {
    ctx.beginPath();
    ctx.ellipse(sx, sy, 2, 1, 0.3, 0, Math.PI * 2);
    ctx.fill();
  });

  // --- Mustard zigzag ---
  ctx.strokeStyle = '#F5D000';
  ctx.lineWidth = 2.5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(x + 5, y + mid);
  for (let i = 0; i < 7; i++) {
    ctx.lineTo(x + 7 + i * 4, y + (i % 2 === 0 ? mid - 3 : mid + 3));
  }
  ctx.stroke();

  // --- Ketchup drizzle ---
  ctx.strokeStyle = '#E8392E';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x + 8, y + mid + 1);
  for (let i = 0; i < 6; i++) {
    ctx.lineTo(x + 10 + i * 4, y + (i % 2 === 0 ? mid + 4 : mid - 1));
  }
  ctx.stroke();
  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';
}

function drawSparkle(cx, cy, size) {
  ctx.beginPath();
  ctx.moveTo(cx, cy - size);
  ctx.lineTo(cx + size * 0.3, cy - size * 0.3);
  ctx.lineTo(cx + size, cy);
  ctx.lineTo(cx + size * 0.3, cy + size * 0.3);
  ctx.lineTo(cx, cy + size);
  ctx.lineTo(cx - size * 0.3, cy + size * 0.3);
  ctx.lineTo(cx - size, cy);
  ctx.lineTo(cx - size * 0.3, cy - size * 0.3);
  ctx.closePath();
  ctx.fill();
}

function drawGoldenHotDog(x, y) {
  const hw = 36;
  const hh = 22;
  const mid = hh / 2;
  const shimmer = 0.5 + 0.5 * Math.sin(frameCount * 0.1);

  // Outer glow
  ctx.save();
  ctx.globalAlpha = 0.3 + shimmer * 0.3;
  ctx.shadowColor = '#FFD700';
  ctx.shadowBlur = 8 + shimmer * 6;

  // --- Dark outline ---
  ctx.strokeStyle = '#8B6914';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x + 10, y + 1);
  ctx.quadraticCurveTo(x + hw / 2, y - 1, x + hw - 10, y + 1);
  ctx.quadraticCurveTo(x + hw - 4, y + 1, x + hw - 2, y + 5);
  ctx.quadraticCurveTo(x + hw + 1, y + mid, x + hw + 1, y + mid + 4);
  ctx.quadraticCurveTo(x + hw + 1, y + hh + 1, x + hw - 7, y + hh + 1);
  ctx.lineTo(x + 7, y + hh + 1);
  ctx.quadraticCurveTo(x - 1, y + hh + 1, x - 1, y + mid + 4);
  ctx.quadraticCurveTo(x - 1, y + mid, x + 2, y + 5);
  ctx.quadraticCurveTo(x + 4, y + 1, x + 10, y + 1);
  ctx.stroke();

  // --- Bun bottom (golden) ---
  ctx.fillStyle = '#FFC107';
  ctx.beginPath();
  ctx.moveTo(x + 5, y + mid + 1);
  ctx.lineTo(x + hw - 5, y + mid + 1);
  ctx.quadraticCurveTo(x + hw, y + mid + 1, x + hw, y + mid + 4);
  ctx.quadraticCurveTo(x + hw, y + hh, x + hw - 7, y + hh);
  ctx.lineTo(x + 7, y + hh);
  ctx.quadraticCurveTo(x, y + hh, x, y + mid + 4);
  ctx.quadraticCurveTo(x, y + mid + 1, x + 5, y + mid + 1);
  ctx.fill();

  // --- Sausage (golden amber) ---
  ctx.fillStyle = '#FFB300';
  roundRect(x - 4, y + 6, hw + 8, 12, 6);
  ctx.fillStyle = '#FFD54F';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2, y + 9, hw / 2 - 2, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FF8F00';
  ctx.beginPath();
  ctx.arc(x - 2, y + 12, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + hw + 2, y + 12, 5, 0, Math.PI * 2);
  ctx.fill();

  // --- Bun top (golden) ---
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(x + 5, y + mid + 1);
  ctx.lineTo(x + hw - 5, y + mid + 1);
  ctx.quadraticCurveTo(x + hw - 2, y + mid, x + hw - 3, y + 5);
  ctx.quadraticCurveTo(x + hw - 5, y + 1, x + hw - 9, y + 1);
  ctx.lineTo(x + 9, y + 1);
  ctx.quadraticCurveTo(x + 5, y + 1, x + 3, y + 5);
  ctx.quadraticCurveTo(x + 2, y + mid, x + 5, y + mid + 1);
  ctx.fill();

  // Bun highlight
  ctx.fillStyle = '#FFEA70';
  ctx.beginPath();
  ctx.moveTo(x + 11, y + 3);
  ctx.quadraticCurveTo(x + hw / 2, y, x + hw - 11, y + 3);
  ctx.lineTo(x + hw - 11, y + 6);
  ctx.quadraticCurveTo(x + hw / 2, y + 3, x + 11, y + 6);
  ctx.closePath();
  ctx.fill();

  // Seam
  ctx.strokeStyle = '#B8860B';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x + 3, y + mid);
  ctx.quadraticCurveTo(x + hw / 2, y + mid - 1, x + hw - 3, y + mid);
  ctx.stroke();

  ctx.restore(); // restore glow state

  // --- Sparkle particles orbiting ---
  for (let i = 0; i < 3; i++) {
    const angle = frameCount * 0.05 + i * (Math.PI * 2 / 3);
    const sparkX = x + hw / 2 + Math.cos(angle) * (hw / 2 + 8);
    const sparkY = y + mid + Math.sin(angle) * (hh / 2 + 6);
    ctx.fillStyle = `rgba(255, 215, 0, ${0.5 + shimmer * 0.5})`;
    drawSparkle(sparkX, sparkY, 3 + shimmer * 2);
  }

  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';
}

function drawHotDogStack(x, y, h) {
  // Two hot dogs stacked on the ground — wobbly pile look
  const offsets = [
    { dx: 2, dy: 20 },
    { dx: -2, dy: 0 },
  ];
  for (const off of offsets) {
    drawHotDog(x + off.dx, y + off.dy);
  }
  // Exclamation mark warning above the stack
  const wobble = Math.sin(frameCount * 0.15) * 2;
  ctx.fillStyle = '#FF1493';
  ctx.font = 'bold 14px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('!', x + 18, y - 8 + wobble);
}

function drawFrisbee(x, y) {
  const fw = 44;
  const fh = 14;
  const spin = frameCount * 0.15;
  const cx = x + fw / 2;
  const cy = y + fh / 2;

  // Shadow on ground (drawn before wobble)
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(cx, GROUND_Y + 26, fw / 2 + 2, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Very subtle x-axis wobble
  const wobble = 0.04 * Math.sin(spin * 1.3);
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(wobble);

  // Outer rim
  ctx.fillStyle = '#FF1493';
  ctx.beginPath();
  ctx.ellipse(0, 0, fw / 2, fh / 2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Inner disc
  ctx.fillStyle = '#FF69B4';
  ctx.beginPath();
  ctx.ellipse(0, 0, fw / 2 - 6, fh / 2 - 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // White ring
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(0, 0, fw / 2 - 4, fh / 2 - 2, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Spin lines
  ctx.strokeStyle = '#D1006E';
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 4; i++) {
    const angle = spin + i * Math.PI / 2;
    const rx = fw / 2 - 4;
    const ry = fh / 2 - 1;
    ctx.beginPath();
    ctx.moveTo(Math.cos(angle) * rx * 0.3, Math.sin(angle) * ry * 0.3);
    ctx.lineTo(Math.cos(angle) * rx * 0.7, Math.sin(angle) * ry * 0.7);
    ctx.stroke();
  }

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.ellipse(-6, -3, 8, 3, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawSquirrelSprite(x, y, flipHorizontal) {
  const frames = squirrelSprites.run;
  const frameIdx = squirrelSpriteFrame % (frames?.length || 1);
  const img = frames && frames[frameIdx];
  if (!img || !img.complete || !img.naturalWidth) return false;
  const sw = img.naturalWidth;
  const sh = img.naturalHeight;
  const dw = sw * SQUIRREL_SPRITE_SCALE;
  const dh = sh * SQUIRREL_SPRITE_SCALE;
  const anchorX = 10;  // center of procedural squirrel (spans x-12 to x+32)
  const dx = x + anchorX - dw / 2;
  const dy = y - dh + SQUIRREL_SPRITE_GROUND_OFFSET;
  if (flipHorizontal) {
    ctx.save();
    ctx.translate(dx + dw / 2, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(dx + dw / 2), 0);
    ctx.drawImage(img, 0, 0, sw, sh, dx, dy, dw, dh);
    ctx.restore();
  } else {
    ctx.drawImage(img, 0, 0, sw, sh, dx, dy, dw, dh);
  }
  return true;
}

function drawSquirrel(x, y, escaping, flipHorizontal) {
  if (squirrelSpritesReady && drawSquirrelSprite(x, y, flipHorizontal || false)) return;

  // Pixel-art squirrel inspired by Elthen/OpenGameArt: bushy tail, compact body, pointy ears.
  // escaping=true: horizontal running pose, tail streaming back.
  const flip = flipHorizontal || false;
  if (flip) {
    ctx.save();
    ctx.translate(x + 10, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(x + 10), 0);
  }
  const runCycle = escaping ? frameCount * 0.4 : frameCount * 0.25;
  const bounce = escaping ? 0 : Math.sin(runCycle) * 2;
  const sy = y - bounce;

  if (escaping) {
    // Fleeing pose: body stretched, tail whipped back, legs in run stride
    ctx.fillStyle = '#5C4435';
    ctx.beginPath();
    ctx.ellipse(x - 12, sy + 10, 12, 8, 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#6B5344';
    ctx.beginPath();
    ctx.ellipse(x - 14, sy + 12, 10, 6, 0.3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#8B7355';
    ctx.beginPath();
    ctx.ellipse(x + 4, sy + 10, 10, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#7A6345';
    ctx.beginPath();
    ctx.ellipse(x + 2, sy + 11, 7, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#8B7355';
    ctx.beginPath();
    ctx.arc(x + 20, sy + 7, 7, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#7A6345';
    ctx.beginPath();
    ctx.moveTo(x + 24, sy + 2);
    ctx.lineTo(x + 28, sy - 4);
    ctx.lineTo(x + 26, sy + 3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 26, sy + 4);
    ctx.lineTo(x + 30, sy - 2);
    ctx.lineTo(x + 28, sy + 5);
    ctx.closePath();
    ctx.fill();

    const legOffset = Math.sin(runCycle) * 3;
    ctx.fillStyle = '#6B5344';
    ctx.fillRect(x + 6, sy + 14, 4, 6 + legOffset);
    ctx.fillRect(x + 14, sy + 14, 4, 6 - legOffset);

    ctx.fillStyle = '#222';
  } else {
    // Idle/teasing pose: upright, bushy tail
    ctx.fillStyle = '#6B5344';
    ctx.beginPath();
    ctx.ellipse(x - 8, sy + 8, 14, 10, 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#5C4435';
    ctx.beginPath();
    ctx.ellipse(x - 10, sy + 10, 10, 6, 0.2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#8B7355';
    ctx.beginPath();
    ctx.ellipse(x + 8, sy + 10, 12, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#7A6345';
    ctx.beginPath();
    ctx.ellipse(x + 6, sy + 12, 8, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#8B7355';
    ctx.beginPath();
    ctx.arc(x + 22, sy + 6, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#6B5344';
    ctx.beginPath();
    ctx.ellipse(x + 18, sy + 4, 4, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#7A6345';
    ctx.beginPath();
    ctx.moveTo(x + 26, sy);
    ctx.lineTo(x + 30, sy - 6);
    ctx.lineTo(x + 28, sy + 2);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 28, sy - 2);
    ctx.lineTo(x + 32, sy - 5);
    ctx.lineTo(x + 30, sy + 1);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#222';
  }

  ctx.beginPath();
  ctx.arc(x + (escaping ? 22 : 24), sy + (escaping ? 8 : 5), 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x + (escaping ? 22.5 : 24.5), sy + (escaping ? 7.5 : 4.5), 0.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#5C3A1E';
  ctx.beginPath();
  ctx.arc(x + (escaping ? 26 : 28), sy + (escaping ? 9 : 7), 2.5, 0, Math.PI * 2);
  ctx.fill();
  if (flip) ctx.restore();
}

function drawAcorn(x, y, rotation) {
  // Teardrop acorn: brown nut, tan cap. Fits ~36x22 like hot dog.
  // rotation: optional radians for spinning (e.g. duck-under acorn)
  const hw = 36;
  const hh = 22;

  if (rotation !== undefined) {
    const cx = x + hw / 2;
    const cy = y + hh / 2;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation);
    ctx.translate(-cx, -cy);
  }

  // Nut body (brown oval)
  ctx.fillStyle = '#6B4423';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2, y + hh / 2 + 2, 12, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#8B5A2B';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2 - 2, y + hh / 2, 10, 8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Cap (tan)
  ctx.fillStyle = '#A67C52';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2, y + 6, 14, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#D4A574';
  ctx.beginPath();
  ctx.ellipse(x + hw / 2 - 2, y + 5, 10, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Stem
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(x + hw / 2 - 1, y + 1, 2, 4);

  if (rotation !== undefined) ctx.restore();
}

function drawAcornPile(x, y, h) {
  // 2-3 acorns stacked, same footprint as hot dog stack
  drawAcorn(x + 4, y + 22);
  drawAcorn(x, y + 10);
  drawAcorn(x + 8, y + 4);
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
}

function drawSky() {
  // Sky gradient colors per stage: [day, sunset, night, dawn] -> top, mid, bottom
  const skyTop = ['#4AB8E8', '#FF8C42', '#0D1B2A', '#6B4E71'];
  const skyMid = ['#87CEEB', '#FF6B6B', '#1B263B', '#9B8AA6'];
  const skyBottom = ['#B0E0F0', '#FFB88C', '#415A77', '#4AB8E8'];
  const { phase } = getTimeOfDay();
  const p = phase * 4;
  const i = Math.floor(p) % 4;
  const t = p % 1;
  const top = lerpColor(skyTop[i], skyTop[(i + 1) % 4], t);
  const mid = lerpColor(skyMid[i], skyMid[(i + 1) % 4], t);
  const bottom = lerpColor(skyBottom[i], skyBottom[(i + 1) % 4], t);
  const grad = ctx.createLinearGradient(0, 0, 0, GROUND_Y + 20);
  grad.addColorStop(0, top);
  grad.addColorStop(0.7, mid);
  grad.addColorStop(1, bottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, GROUND_Y + 20);
}

function drawSun() {
  const sunX = 700;
  const { phase, stage, t } = getTimeOfDay();

  // Sun visible: day + sunset; hidden: night; fading in: dawn
  const sunOpacity = phase < 0.5 ? 1 : phase < 0.75 ? 0 : t;
  const moonOpacity = phase < 0.5 ? 0 : phase < 0.75 ? 1 : 1 - t;

  // Sun Y: day=45, sunset=sinks to 65
  const sunY = phase < 0.25 ? 45 : phase < 0.5 ? 45 + (phase - 0.25) / 0.25 * 20 : 65;

  // Sun color: yellow (day) -> orange (sunset)
  const sunColor = phase < 0.25 ? '#FFD700' : phase < 0.5 ? lerpColor('#FFD700', '#FF8C00', (phase - 0.25) / 0.25) : '#FF8C00';

  // Stars (night/dawn only) — deterministic positions
  if (moonOpacity > 0.01) {
    const starPositions = [[120, 35], [280, 22], [420, 48], [550, 28], [650, 40], [180, 55], [340, 62], [480, 38]];
    starPositions.forEach(([sx, sy]) => {
      ctx.globalAlpha = moonOpacity * (0.6 + Math.sin(sx * 0.1 + frameCount * 0.02) * 0.4);
      ctx.fillStyle = '#FFFFFF';
      ctx.beginPath();
      ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  // Moon (night/dawn)
  if (moonOpacity > 0.01) {
    const moonX = 700;
    const moonY = 50;
    const moonR = 12;
    ctx.globalAlpha = moonOpacity;
    ctx.fillStyle = '#E8E8E8';
    ctx.beginPath();
    ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#D0D0D0';
    ctx.beginPath();
    ctx.arc(moonX - 3, moonY - 2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(moonX + 4, moonY + 2, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Sun (day/sunset/dawn)
  if (sunOpacity > 0.01) {
    const drawY = phase >= 0.75 ? 45 : sunY;
    const glow = ctx.createRadialGradient(sunX, drawY, 15, sunX, drawY, 50);
    glow.addColorStop(0, `rgba(255, 244, 130, ${0.4 * sunOpacity})`);
    glow.addColorStop(1, 'rgba(255, 244, 130, 0)');
    ctx.globalAlpha = sunOpacity;
    ctx.fillStyle = glow;
    ctx.fillRect(sunX - 50, drawY - 50, 100, 100);

    if (stage !== 'night') {
      ctx.save();
      ctx.translate(sunX, drawY);
      ctx.rotate(frameCount * 0.005);
      ctx.fillStyle = stage === 'sunset' ? '#FFB366' : '#FFE066';
      for (let i = 0; i < 8; i++) {
        ctx.rotate(Math.PI / 4);
        ctx.fillRect(-2, 20, 4, 10);
      }
      ctx.restore();
    }

    ctx.fillStyle = sunColor;
    ctx.beginPath();
    ctx.arc(sunX, drawY, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = stage === 'sunset' ? '#FFCC80' : '#FFF176';
    ctx.beginPath();
    ctx.arc(sunX - 4, drawY - 4, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawGround() {
  const { phase } = getTimeOfDay();
  const p = phase * 4;
  const i = Math.floor(p) % 4;
  const t = p % 1;

  // Path colors: [day=sandy, sunset=warm amber, night=dark brown, dawn=sandy]
  const pathTop = ['#E8D5A3', '#E8B870', '#5C4033', '#E8D5A3'];
  const pathBottom = ['#D4C08E', '#D4A055', '#3D2B1F', '#D4C08E'];
  const pathTex = ['#C9B57A', '#C9A055', '#4A3728', '#C9B57A'];
  const pathTopC = lerpColor(pathTop[i], pathTop[(i + 1) % 4], t);
  const pathBottomC = lerpColor(pathBottom[i], pathBottom[(i + 1) % 4], t);
  const pathTexC = lerpColor(pathTex[i], pathTex[(i + 1) % 4], t);

  const pathGrad = ctx.createLinearGradient(0, GROUND_Y + 16, 0, GROUND_Y + 34);
  pathGrad.addColorStop(0, pathTopC);
  pathGrad.addColorStop(1, pathBottomC);
  ctx.fillStyle = pathGrad;
  ctx.fillRect(0, GROUND_Y + 16, W, 20);

  ctx.fillStyle = pathTexC;
  for (let i = 0; i < W; i += 18) {
    const gx = (i - groundOffset % 18 + W) % W;
    ctx.fillRect(gx, GROUND_Y + 22, 4, 2);
    ctx.fillRect((gx + 9) % W, GROUND_Y + 28, 3, 2);
  }

  // Grass: [day=green, sunset=warm-tinted, night=very dark, dawn=returning]
  const grassTop = ['#5DBE3E', '#6B8E3E', '#1A2E1A', '#5DBE3E'];
  const grassMid = ['#4CAF30', '#5A7E30', '#152515', '#4CAF30'];
  const grassBottom = ['#3D8B28', '#4A6B28', '#0F1F0F', '#3D8B28'];
  const grassBlade = ['#6ECF4A', '#7A9F4A', '#2A3A2A', '#6ECF4A'];
  const grassTopC = lerpColor(grassTop[i], grassTop[(i + 1) % 4], t);
  const grassMidC = lerpColor(grassMid[i], grassMid[(i + 1) % 4], t);
  const grassBottomC = lerpColor(grassBottom[i], grassBottom[(i + 1) % 4], t);
  const grassBladeC = lerpColor(grassBlade[i], grassBlade[(i + 1) % 4], t);

  const grassGrad = ctx.createLinearGradient(0, GROUND_Y + 36, 0, H);
  grassGrad.addColorStop(0, grassTopC);
  grassGrad.addColorStop(0.4, grassMidC);
  grassGrad.addColorStop(1, grassBottomC);
  ctx.fillStyle = grassGrad;
  ctx.fillRect(0, GROUND_Y + 36, W, H - GROUND_Y - 36);

  ctx.fillStyle = grassBladeC;
  for (let i = 0; i < W; i += 6) {
    const gx = (i - groundOffset % 6 + W) % W;
    const h = 3 + Math.sin(gx * 0.5) * 2;
    ctx.fillRect(gx, GROUND_Y + 34 - h, 3, h + 3);
  }
  for (let i = 0; i < W; i += 8) {
    const gx = (i - groundOffset % 8 + W) % W;
    const h = 2 + Math.sin(gx * 0.7) * 2;
    ctx.fillRect(gx, GROUND_Y + 14 - h, 2, h + 3);
  }
}

function drawFlowers() {
  const { phase } = getTimeOfDay();
  const p = phase * 4;
  const i = Math.floor(p) % 4;
  const t = p % 1;
  const flowerVis = [1, 0.9, 0.35, 0.7];
  const flowerOp = flowerVis[i] + (flowerVis[(i + 1) % 4] - flowerVis[i]) * t;

  flowers.forEach(f => {
    const fx = (f.x - groundOffset * 0.8 % W + W) % W;
    const s = f.size;

    ctx.globalAlpha = flowerOp;
    ctx.fillStyle = phase >= 0.5 && phase < 0.75 ? '#2A3A2A' : '#2E8B2E';
    ctx.fillRect(fx, f.baseY - f.size * 2, 2, f.size * 2 + 2);

    ctx.fillStyle = phase >= 0.5 && phase < 0.75 ? lerpColor(f.color, '#2A2A3A', 0.6) : f.color;
    ctx.fillRect(fx - s + 1, f.baseY - s * 3, s, s);
    ctx.fillRect(fx + 2, f.baseY - s * 3, s, s);
    ctx.fillRect(fx - s + 1, f.baseY - s * 1.5, s, s);
    ctx.fillRect(fx + 2, f.baseY - s * 1.5, s, s);

    ctx.fillStyle = phase >= 0.5 && phase < 0.75 ? '#4A4A40' : '#FFD700';
    ctx.fillRect(fx, f.baseY - s * 2.5 + 1, s - 1, s - 1);
    ctx.globalAlpha = 1;
  });
}

function drawClouds() {
  const { phase } = getTimeOfDay();
  const p = phase * 4;
  const i = Math.floor(p) % 4;
  const t = p % 1;
  // Cloud colors: [day=white, sunset=pinkish, night=dark gray, dawn=lightening]
  const cloudFill = ['#FFFFFF', '#FFD4D4', '#3A3A4A', '#E8E8F0'];
  const cloudShadow = ['#B4DCF0', '#E8B4C0', '#2A2A35', '#B0B8D0'];
  const fillC = lerpColor(cloudFill[i], cloudFill[(i + 1) % 4], t);
  const shadowC = lerpColor(cloudShadow[i], cloudShadow[(i + 1) % 4], t);
  const highlightAlphas = [0.8, 0.6, 0.2, 0.5];
  const highlightAlpha = highlightAlphas[i] + (highlightAlphas[(i + 1) % 4] - highlightAlphas[i]) * t;

  clouds.forEach(c => {
    const s = c.size;
    ctx.fillStyle = shadowC + '80';
    ctx.beginPath();
    ctx.arc(c.x + 18 * s, c.y + 6 * s, 14 * s, 0, Math.PI * 2);
    ctx.arc(c.x + 34 * s, c.y + 4 * s, 10 * s, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = fillC;
    ctx.beginPath();
    ctx.arc(c.x + 10 * s, c.y, 10 * s, 0, Math.PI * 2);
    ctx.arc(c.x + 24 * s, c.y - 6 * s, 14 * s, 0, Math.PI * 2);
    ctx.arc(c.x + 38 * s, c.y - 2 * s, 10 * s, 0, Math.PI * 2);
    ctx.arc(c.x + 20 * s, c.y + 2 * s, 12 * s, 0, Math.PI * 2);
    ctx.arc(c.x + 34 * s, c.y + 2 * s, 8 * s, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = `rgba(255,255,255,${highlightAlpha})`;
    ctx.beginPath();
    ctx.arc(c.x + 22 * s, c.y - 8 * s, 8 * s, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Draw a single hill/mountain layer as a filled path
function drawHillLayer(scrollRate, baseY, amp, freq, fillColors, shapeFn, step) {
  const { phase } = getTimeOfDay();
  const p = phase * 4;
  const idx = Math.floor(p) % 4;
  const t = p % 1;

  const fill = lerpColor(fillColors[idx], fillColors[(idx + 1) % 4], t);
  const offset = groundOffset * scrollRate;
  const yFn = shapeFn || hillY;
  const dx = step || 4;

  ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y + 20);
  for (let x = 0; x <= W; x += dx) {
    const y = baseY - yFn(x, offset, amp, freq);
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, GROUND_Y + 20);
  ctx.closePath();
  ctx.fill();
}

function drawFarHills() {
  // Mountain range: jagged peaks, taller, slower, finer step for crisper ridgeline
  drawHillLayer(0.06, GROUND_Y - 20, 50, 0.0028,
    ['#8090A8', '#B88878', '#161C28', '#686080'], mountainY, 2);
}

function drawNearHills() {
  // Mid hills: medium undulations
  drawHillLayer(0.20, GROUND_Y - 2, 20, 0.006,
    ['#7BA888', '#B08860', '#162420', '#688070']);
  // Near hills: smaller, fastest, most saturated
  drawHillLayer(0.38, GROUND_Y + 4, 14, 0.010,
    ['#5D9E58', '#988050', '#1A2E1A', '#5A7858']);
}

function drawScore() {
  ctx.font = 'bold 18px Courier New';
  ctx.textAlign = 'right';

  const scoreStr = String(Math.floor(score)).padStart(5, '0');
  const hi = highScores[0]?.score ?? highScore;
  if (hi > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillText('HI ' + String(Math.floor(hi)).padStart(5, '0') + '  ', W - 100, 30);
  }
  ctx.fillStyle = '#fff';
  ctx.fillText(scoreStr, W - 15, 30);

  // Giant mode multiplier + timer bar
  if (giantActive) {
    const remaining = GIANT_DURATION - (performance.now() - giantStartTime);
    const flash = remaining < GIANT_WARN_AT ? (Math.sin(performance.now() * 0.015) > 0) : true;
    if (flash) {
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('x' + GIANT_SCORE_MULTIPLIER, 14, 48);
    }
    // Timer bar
    const barW = 60;
    const barH = 4;
    const barX = 14;
    const barY = 52;
    const fill = Math.max(0, remaining / GIANT_DURATION);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.fillStyle = remaining < GIANT_WARN_AT ? '#FF6347' : '#FFD700';
    ctx.fillRect(barX, barY, barW * fill, barH);
  }
}

function drawLocalLeaderboard(baseY) {
  const panelW = 280;
  const panelH = highScores.length === 0 ? 44 : 28 + highScores.length * 18;
  const px = W / 2 - panelW / 2;

  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  roundRect(px, baseY, panelW, panelH, 8);

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('HIGH SCORES', W / 2, baseY + 20);

  if (highScores.length === 0) {
    ctx.font = '14px Courier New';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.fillText('(no scores yet)', W / 2, baseY + 38);
  } else {
    ctx.font = '16px Courier New';
    highScores.forEach((entry, i) => {
      const lineY = baseY + 38 + i * 18;
      ctx.textAlign = 'left';
      ctx.fillStyle = '#fff';
      ctx.fillText(`${i + 1}. ${entry.name.padEnd(10)}`, px + 16, lineY);
      ctx.textAlign = 'right';
      ctx.fillText(String(Math.floor(entry.score)).padStart(5, '0'), px + panelW - 16, lineY);
    });
  }
}

function drawMusicIcon() {
  const ix = 14, iy = 16;
  // Speaker body
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.moveTo(ix, iy);
  ctx.lineTo(ix + 6, iy);
  ctx.lineTo(ix + 12, iy - 5);
  ctx.lineTo(ix + 12, iy + 11);
  ctx.lineTo(ix + 6, iy + 6);
  ctx.lineTo(ix, iy + 6);
  ctx.closePath();
  ctx.fill();

  if (musicOn) {
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(ix + 14, iy + 3, 4, -Math.PI / 3, Math.PI / 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(ix + 14, iy + 3, 8, -Math.PI / 3, Math.PI / 3);
    ctx.stroke();
  } else {
    ctx.strokeStyle = 'rgba(255,100,100,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ix + 15, iy - 2);
    ctx.lineTo(ix + 23, iy + 8);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ix + 23, iy - 2);
    ctx.lineTo(ix + 15, iy + 8);
    ctx.stroke();
  }
}

// ============================================================
//  GAME LOGIC
// ============================================================

function jump() {
  if (gameState === 'enteringName') return;
  if (gameState === 'idle') {
    gameState = 'running';
    score = 0;
    lastMilestone = 0;
    speed = INITIAL_SPEED;
    obstacles = [];
    landingParticles = [];
    nextObstacleIn = 60;
    lastObstacleType = 'hotdog';
    chaseActive = false;
    chasePending = false;
    chaseEntering = false;
    chaseEscaping = false;
    lastChaseEndScore = 0;
    bossPending = false;
    bossChasing = false;
    bossLosing = false;
    lastBossMilestone = 0;
    bossDogShift = 0;
    dog.x = DOG_BASE_X;
    giantActive = false;
    giantGrowing = false;
    giantShrinking = false;
    giantScoreMultiplier = 1;
    giantChompEffects = [];
    giantBonkEffects = [];
    lastGoldenSpawnScore = 0;
    if (giantMusicActive && musicOn) switchToNormalMusic();
    giantMusicActive = false;
  }
  if (gameState === 'dead') {
    if (Date.now() - deathTime < 1000) return;
    gameState = 'running';
    score = 0;
    lastMilestone = 0;
    speed = INITIAL_SPEED;
    obstacles = [];
    landingParticles = [];
    nextObstacleIn = 60;
    lastObstacleType = 'hotdog';
    dog.x = DOG_BASE_X;
    dog.y = GROUND_Y;
    dog.vy = 0;
    dog.jumping = false;
    dog.doubleJumped = false;
    dog.ducking = false;
    chaseActive = false;
    chasePending = false;
    chaseEntering = false;
    chaseEscaping = false;
    lastChaseEndScore = 0;
    bossPending = false;
    bossChasing = false;
    bossLosing = false;
    lastBossMilestone = 0;
    bossDogShift = 0;
    giantActive = false;
    giantGrowing = false;
    giantShrinking = false;
    giantScoreMultiplier = 1;
    giantChompEffects = [];
    giantBonkEffects = [];
    lastGoldenSpawnScore = 0;
    if (giantMusicActive && musicOn) switchToNormalMusic();
    giantMusicActive = false;
  }
  if (gameState !== 'running') return;
  if (dog.ducking) return;

  if (!dog.jumping) {
    dog.vy = JUMP_FORCE;
    dog.jumping = true;
    dog.doubleJumped = false;
    playJumpSound();
  } else if (!dog.doubleJumped) {
    dog.vy = DOUBLE_JUMP_FORCE;
    dog.doubleJumped = true;
    playDoubleJumpSound();
  }
}

function duck(active) {
  if (gameState !== 'running') return;
  if (active && !dog.jumping) {
    if (!dog.ducking) playDuckSound();
    dog.ducking = true;
  } else {
    dog.ducking = false;
  }
}

function spawnObstacle() {
  // --- Golden hot dog spawn check ---
  const goldenEligible = !giantActive && !giantGrowing && !giantShrinking
    && !chaseActive && !chasePending && !chaseEntering
    && !bossPending && !bossChasing && !bossLosing
    && score >= GIANT_FIRST_AT
    && score >= lastGoldenSpawnScore + GIANT_COOLDOWN
    && Math.random() < GIANT_SPAWN_CHANCE;
  if (goldenEligible) {
    obstacles.push({
      x: W + 10,
      y: GROUND_Y + 4,
      width: 36,
      height: 22,
      type: 'golden',
    });
    lastGoldenSpawnScore = score;
    nextObstacleIn = MIN_OBSTACLE_GAP + Math.random() * MAX_OBSTACLE_GAP;
    lastObstacleType = 'golden';
    return;
  }

  let type = 'hotdog';
  const r = Math.random();
  if (score > 150 && r < 0.15) {
    type = 'stack';
  } else if (score > 80 && r < 0.40) {
    type = 'frisbee';
  }

  const spawnX = chaseActive ? (dog.x + SQUIRREL_OFFSET) : (W + 10);
  const skin = chaseActive ? 'chase' : undefined;

  if (type === 'frisbee') {
    // Lower frisbee (duck-under)
    obstacles.push({
      x: spawnX,
      y: GROUND_Y - 12,
      width: 44,
      height: 14,
      type: 'frisbee',
      skin,
    });
    // Upper frisbee stacked above — discourages jumping over
    obstacles.push({
      x: spawnX,
      y: GROUND_Y - 12 - 14 - 6,
      width: 44,
      height: 14,
      type: 'frisbee',
      skin,
    });
  } else if (type === 'stack') {
    obstacles.push({
      x: spawnX,
      y: GROUND_Y + 4 - 20,
      width: 36,
      height: 42,
      type: 'stack',
      skin,
    });
  } else {
    obstacles.push({
      x: spawnX,
      y: GROUND_Y + 4,
      width: 36,
      height: 22,
      type: 'hotdog',
      skin,
    });
  }

  // When switching types, give extra gap so player can react
  if (type !== lastObstacleType) {
    nextObstacleIn = MIN_OBSTACLE_GAP * 1.5 + Math.random() * MAX_OBSTACLE_GAP;
  }
  lastObstacleType = type;
}

function checkCollision() {
  // Dog hitbox changes when ducking (lower profile avoids frisbees)
  let dx, dy, dw, dh;
  if (dog.ducking) {
    dx = dog.x + 23;
    dy = dog.y + 10;
    dw = 50;
    dh = 8;
  } else {
    dx = dog.x + 23;
    dy = dog.y - 8;
    dw = 50;
    dh = 22;
  }

  // When giant, expand hitbox proportionally
  if (giantActive) {
    const expansion = (GIANT_SCALE - 1) * 0.5;
    dx -= dw * expansion * 0.5;
    dy -= dh * expansion;
    dw *= (1 + expansion);
    dh *= (1 + expansion);
  }

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    let ox, oy, ow, oh;
    if (obs.type === 'frisbee') {
      ox = obs.x + 6;
      oy = obs.y + 2;
      ow = obs.width - 12;
      oh = obs.height - 4;
    } else if (obs.type === 'stack') {
      ox = obs.x + 8;
      oy = obs.y + 4;
      ow = obs.width - 16;
      oh = obs.height - 6;
    } else {
      ox = obs.x + 12;
      oy = obs.y + 8;
      ow = obs.width - 24;
      oh = obs.height - 10;
    }

    if (dx < ox + ow && dx + dw > ox && dy < oy + oh && dy + dh > oy) {
      // Golden hot dog: activate giant mode
      if (obs.type === 'golden') {
        activateGiantMode();
        obstacles.splice(i, 1);
        continue;
      }

      // Giant mode: eat or bonk
      if (giantActive) {
        if (obs.type === 'frisbee') {
          triggerBonkEffect(obs);
          playBonkSound();
          score += GIANT_BONK_BONUS;
        } else {
          triggerChompEffect(obs);
          playCrunchSound();
          score += GIANT_EAT_BONUS;
        }
        obstacles.splice(i, 1);
        continue;
      }

      // Normal collision: death
      return true;
    }
  }
  return false;
}

// --- Giant mode lifecycle ---
function activateGiantMode() {
  giantActive = true;
  giantStartTime = performance.now();
  giantGrowing = true;
  giantShrinking = false;
  giantTransitionStart = performance.now();
  giantScoreMultiplier = GIANT_SCORE_MULTIPLIER;
  playGiantActivateSound();
  if (musicOn) switchToGiantMusic();
}

function deactivateGiantMode() {
  giantActive = false;
  giantShrinking = true;
  giantGrowing = false;
  giantTransitionStart = performance.now();
  giantScoreMultiplier = 1;
  playGiantDeactivateSound();
  if (giantMusicActive) switchToNormalMusic();
}

let giantMusicActive = false;

function switchToGiantMusic() {
  giantMusicActive = true;
  if (musicOn) {
    musicNormal.pause();
    musicGiant.currentTime = musicNormal.currentTime % (musicGiant.duration || 1);
    musicGiant.play().catch(() => {});
  }
}

function switchToNormalMusic() {
  giantMusicActive = false;
  if (musicOn) {
    musicGiant.pause();
    musicNormal.currentTime = musicGiant.currentTime % (musicNormal.duration || 1);
    musicNormal.play().catch(() => {});
  }
}

function getGiantVisualScale() {
  const now = performance.now();
  if (giantGrowing) {
    const t = Math.min(1, (now - giantTransitionStart) / GIANT_SCALE_TRANSITION);
    const eased = t * (2 - t); // ease-out
    if (t >= 1) giantGrowing = false;
    return 1 + (GIANT_SCALE - 1) * eased;
  }
  if (giantShrinking) {
    const t = Math.min(1, (now - giantTransitionStart) / GIANT_SCALE_TRANSITION);
    const eased = t * (2 - t);
    if (t >= 1) giantShrinking = false;
    return GIANT_SCALE - (GIANT_SCALE - 1) * eased;
  }
  if (giantActive) return GIANT_SCALE;
  return 1;
}

function triggerChompEffect(obs) {
  giantChompEffects.push({
    x: obs.x,
    y: obs.y,
    startTime: performance.now(),
  });
}

function triggerBonkEffect(obs) {
  giantBonkEffects.push({
    x: obs.x,
    y: obs.y,
    vx: 3 + Math.random() * 2,
    vy: -6 - Math.random() * 3,
    rotation: 0,
    rotSpeed: 0.3 + Math.random() * 0.3,
    startTime: performance.now(),
    type: obs.type,
  });
}

// ============================================================
//  MAIN LOOP
// ============================================================

const DT_BASELINE = 1000 / 120;
function update(dt) {
  if (gameState !== 'running') return;

  const scale = (dt / DT_BASELINE) * (slowMode ? 0.5 : 1);
  frameCount++;
  speed = Math.min(MAX_SPEED, INITIAL_SPEED + score * SPEED_INCREMENT);

  // Boss speed scaling: ramp over approach phase, drop back to normal during losing
  const bossSpeedMult = bossChasing
    ? 1 + (BOSS_SPEED_MULTIPLIER - 1) * Math.min(1, bossChaseFrames / (BOSS_CHASE_DURATION * 0.15))
    : 1;
  const effectiveSpeed = speed * bossSpeedMult;

  // Dog physics (scale by dt for frame-rate independence)
  const wasInAir = dog.y < GROUND_Y;
  dog.vy += GRAVITY * scale;
  dog.y += dog.vy * scale;
  if (dog.y >= GROUND_Y) {
    dog.y = GROUND_Y;
    dog.vy = 0;
    dog.jumping = false;
    dog.doubleJumped = false;
    // Dust puffs on landing (only when actually coming down from a jump)
    if (wasInAir && gameState === 'running') {
      const n = 3 + Math.floor(Math.random() * 3);
      for (let i = 0; i < n; i++) {
        landingParticles.push({
          x: dog.x + 30 + (Math.random() - 0.5) * 40,
          y: GROUND_Y,
          vx: (Math.random() - 0.5) * 0.8,
          vy: -1.5 - Math.random() * 2,
          life: 1,
          hue: Math.random() * 360,
        });
      }
    }
  }

  // Leg animation
  dog.legFrame += effectiveSpeed * 0.06 * scale;

  // Ground scroll
  groundOffset += effectiveSpeed * scale;

  // Clouds scroll (slower)
  clouds.forEach(c => {
    c.x -= effectiveSpeed * 0.15 * scale;
    if (c.x < -60 * c.size) {
      c.x = W + Math.random() * 100;
      c.y = 20 + Math.random() * 50;
      c.size = 0.6 + Math.random() * 0.8;
    }
  });

  // Obstacles
  nextObstacleIn -= effectiveSpeed * scale;
  if (nextObstacleIn <= 0 && !chasePending && !chaseEntering && !bossPending && !bossLosing) {
    spawnObstacle();
    if (nextObstacleIn <= 0) {
      const gap = bossChasing
        ? MIN_OBSTACLE_GAP * BOSS_OBSTACLE_GAP_MULTIPLIER
        : MIN_OBSTACLE_GAP;
      nextObstacleIn = gap + Math.random() * MAX_OBSTACLE_GAP;
    }
  }

  obstacles.forEach(o => o.x -= effectiveSpeed * scale);
  obstacles = obstacles.filter(o => o.x > -40);

  // Landing dust particles
  landingParticles = landingParticles.filter(p => {
    p.x += p.vx * scale;
    p.y += p.vy * scale;
    p.vy += 0.08 * scale;  // light upward drift, then settle
    p.life -= 0.04 * scale;
    return p.life > 0;
  });

  // Score (with giant multiplier)
  score += effectiveSpeed * 0.02 * scale * giantScoreMultiplier;

  // Giant mode timer
  if (giantActive) {
    const elapsed = performance.now() - giantStartTime;
    if (elapsed >= GIANT_DURATION) {
      deactivateGiantMode();
    }
  }
  // Update chomp/bonk visual effects
  const now = performance.now();
  giantChompEffects = giantChompEffects.filter(e => now - e.startTime < 500);
  giantBonkEffects = giantBonkEffects.filter(e => {
    e.x += e.vx * scale;
    e.y += e.vy * scale;
    e.vy += 0.3 * scale;
    e.rotation += e.rotSpeed * scale;
    return now - e.startTime < 1500;
  });

  // Chase mode
  if (chaseActive) {
    if (frameCount - chaseStartedFrame >= CHASE_DURATION_FRAMES) {
      chaseActive = false;
      chaseEscaping = true;
      squirrelEscapeX = dog.x + SQUIRREL_OFFSET;
      squirrelEscapeSpeed = 1.5;
      lastChaseEndScore = score;
    }
  } else if (chaseEscaping) {
    squirrelEscapeX += squirrelEscapeSpeed * scale;
    squirrelEscapeSpeed = Math.min(3.5, squirrelEscapeSpeed + 0.004 * scale);
    if (squirrelEscapeX > W + 80) {
      chaseEscaping = false;
    }
  } else if (chaseEntering) {
    squirrelEnterX -= squirrelEnterSpeed * scale;
    squirrelEnterSpeed = Math.min(3.5, squirrelEnterSpeed + 0.004 * scale);
    if (squirrelEnterX <= dog.x + SQUIRREL_OFFSET) {
      squirrelEnterX = dog.x + SQUIRREL_OFFSET;
      chaseEntering = false;
      chaseActive = true;
      chaseStartedFrame = frameCount;
      nextObstacleIn = 80;  // first chase obstacle spawns soon after squirrel arrives
    }
  } else if (chasePending) {
    if (obstacles.length === 0) {
      chasePending = false;
      chaseEntering = true;
      squirrelEnterX = W + 80;  // start off-screen right
      squirrelEnterSpeed = 1.5;
    }
  } else {
    const canStart = !giantActive && !bossPending && !bossChasing && !bossLosing &&
      ((lastChaseEndScore === 0 && score >= CHASE_FIRST_AT) ||
      (lastChaseEndScore > 0 && score >= lastChaseEndScore + CHASE_COOLDOWN));
    if (canStart) {
      chasePending = true;
    }
  }

  // Boss chase state machine
  if (bossChasing) {
    // Frame-based timer: encounter duration is constant regardless of game speed
    bossChaseFrames += scale;
    const escapeProgress = Math.min(1, bossChaseFrames / BOSS_CHASE_DURATION);
    // Asymmetric curve: approach (15%), long hold at peak (75%), quick retreat (10%)
    let approachCurve;
    if (escapeProgress < 0.15) {
      const t = escapeProgress / 0.15;
      approachCurve = t * t;  // ease-in approach
    } else if (escapeProgress < 0.90) {
      approachCurve = 1;      // hold at peak — squirrel right on the dog's tail
    } else {
      const t = (escapeProgress - 0.90) / 0.10;
      approachCurve = 1 - t * t;  // ease-out retreat
    }

    // Dog shifts right (less reaction time to obstacles)
    bossDogShift = Math.min(BOSS_MAX_DOG_SHIFT, bossDogShift + BOSS_DOG_SHIFT_SPEED * scale);
    dog.x = DOG_BASE_X + bossDogShift;

    // Squirrel follows behind the shifted dog
    const peakX = dog.x - 70;
    bossSquirrelX = BOSS_SQUIRREL_START_X + (peakX - BOSS_SQUIRREL_START_X) * approachCurve;

    // Transition: dog escapes
    if (bossChaseFrames >= BOSS_CHASE_DURATION) {
      bossLosing = true;
      bossChasing = false;
    }
    // Collision: squirrel catches dog
    const sqRight = bossSquirrelX + 30;
    const sqLeft = bossSquirrelX;
    const sqTop = GROUND_Y + 4;
    const sqBottom = sqTop + 20;
    let dx, dy, dw, dh;
    if (dog.ducking) {
      dx = dog.x + 23; dy = dog.y + 10; dw = 50; dh = 8;
    } else {
      dx = dog.x + 23; dy = dog.y - 8; dw = 50; dh = 22;
    }
    if (sqRight > dx && sqLeft < dx + dw && sqBottom > dy && sqTop < dy + dh) {
      // Squirrel caught the dog — game over
      deathTime = Date.now();
      playDeathSound();
      bossChasing = false; bossLosing = false; bossPending = false;
      chaseActive = false; chasePending = false; chaseEntering = false; chaseEscaping = false;
      const localQualifies = highScores.length < MAX_HIGH_SCORES || score > (highScores[MAX_HIGH_SCORES - 1]?.score ?? 0);
      const globalQualifies = globalScoresLoaded && (globalHighScores.length < GLOBAL_MAX_SCORES || score > (globalHighScores[GLOBAL_MAX_SCORES - 1]?.score ?? 0));
      const qualifies = localQualifies || globalQualifies;
      if (qualifies) {
        gameState = 'enteringName';
        pendingScore = score;
        showNameEntryOverlay();
      } else {
        gameState = 'dead';
        if (score > highScore) highScore = score;
      }
    }
  } else if (bossLosing) {
    // Dog returns to base position smoothly — but only while grounded
    if (!dog.jumping) {
      bossDogShift = Math.max(0, bossDogShift - BOSS_DOG_RETURN_SPEED * scale);
    }
    dog.x = DOG_BASE_X + bossDogShift;
    // Squirrel retreats left
    bossSquirrelX -= BOSS_SQUIRREL_LOSE_SPEED * scale;
    // Boss ends only when dog is fully back AND squirrel has exited
    if (bossSquirrelX < BOSS_SQUIRREL_START_X - 60 && bossDogShift <= 0) {
      bossLosing = false;
    }
  } else if (bossPending) {
    if (obstacles.length === 0) {
      bossPending = false;
      bossChasing = true;
      bossSquirrelX = BOSS_SQUIRREL_START_X;
      bossChaseFrames = 0;
    }
  } else {
    // Boss trigger check: fires at 1000, 2000, 3000... (mutual exclusion with chase)
    const currentMilestone = Math.floor(score / BOSS_MILESTONE);
    const bossCanStart = !giantActive && !chasePending && !chaseActive && !chaseEntering && !chaseEscaping &&
      currentMilestone > lastBossMilestone;
    if (bossCanStart) {
      bossPending = true;
      lastBossMilestone = currentMilestone;
      chasePending = false;  // cancel any pending chase
    }
  }

  // Chime at 100-point milestones
  const milestone = Math.floor(score / 100);
  if (milestone > lastMilestone) {
    lastMilestone = milestone;
    playScoreSound();
  }

  // Collision
  if (checkCollision()) {
    deathTime = Date.now();
    playDeathSound();
    chaseActive = false;
    chasePending = false;
    chaseEntering = false;
    chaseEscaping = false;
    bossPending = false;
    bossChasing = false;
    bossLosing = false;
    giantActive = false;
    giantGrowing = false;
    giantShrinking = false;
    giantScoreMultiplier = 1;
    if (giantMusicActive && musicOn) switchToNormalMusic();
    giantMusicActive = false;
    const localQualifies = highScores.length < MAX_HIGH_SCORES || score > (highScores[MAX_HIGH_SCORES - 1]?.score ?? 0);
    const globalQualifies = globalScoresLoaded && (globalHighScores.length < GLOBAL_MAX_SCORES || score > (globalHighScores[GLOBAL_MAX_SCORES - 1]?.score ?? 0));
    const qualifies = localQualifies || globalQualifies;
    if (qualifies) {
      gameState = 'enteringName';
      pendingScore = score;
      showNameEntryOverlay();
    } else {
      gameState = 'dead';
      if (score > highScore) highScore = score;
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(2, 2);

  // Screen shake on death (decaying over ~250ms)
  if ((gameState === 'dead' || gameState === 'enteringName') && deathTime > 0) {
    const elapsed = Date.now() - deathTime;
    if (elapsed < 250) {
      const decay = 1 - elapsed / 250;
      const intensity = 6 * decay;
      ctx.translate((Math.random() - 0.5) * 2 * intensity, (Math.random() - 0.5) * 2 * intensity);
    }
  }

  drawSky();
  drawSun();
  drawClouds();
  drawFarHills();
  drawNearHills();
  drawGround();
  drawFlowers();

  // Draw obstacles
  obstacles.forEach(o => {
    if (o.type === 'golden') {
      drawGoldenHotDog(o.x, o.y);
    } else {
      const useChaseSkin = (o.skin ?? (chaseActive ? 'chase' : 'normal')) === 'chase';
      if (useChaseSkin) {
        if (o.type === 'frisbee') drawAcorn(o.x, o.y - 8, frameCount * 0.15);
        else if (o.type === 'stack') drawAcornPile(o.x, o.y, o.height);
        else drawAcorn(o.x, o.y);
      } else {
        if (o.type === 'frisbee') drawFrisbee(o.x, o.y);
        else if (o.type === 'stack') drawHotDogStack(o.x, o.y, o.height);
        else drawHotDog(o.x, o.y);
      }
    }
  });

  // Draw boss squirrel (behind the dog, drawn first so it appears on left)
  // Comically oversized — scale around feet so it stays grounded
  if (bossChasing || bossLosing) {
    advanceSquirrelSpriteFrame();
    const bossScale = 2.5;
    const pivotX = bossSquirrelX + 10;
    const pivotY = GROUND_Y + 24;
    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.scale(bossScale, bossScale);
    ctx.translate(-pivotX, -pivotY);
    if (bossChasing) {
      drawSquirrel(bossSquirrelX, GROUND_Y + 4, false, false);
    } else {
      drawSquirrel(bossSquirrelX, GROUND_Y + 4, true, true);
    }
    ctx.restore();
  }

  // Draw squirrel (during chase, entering, or escaping, before dog so it appears ahead)
  if (chaseActive && !bossChasing && !bossLosing) {
    advanceSquirrelSpriteFrame();
    drawSquirrel(dog.x + SQUIRREL_OFFSET, GROUND_Y + 4, false);
  } else if (chaseEntering && !bossChasing && !bossLosing) {
    advanceSquirrelSpriteFrame();
    drawSquirrel(squirrelEnterX, GROUND_Y + 4, true, true);  // running left (flip)
  } else if (chaseEscaping && !bossChasing && !bossLosing) {
    advanceSquirrelSpriteFrame();
    drawSquirrel(squirrelEscapeX, GROUND_Y + 4, true);
  }

  // Draw dachshund (PNG sprites when loaded, else procedural)
  advanceDogSpriteFrame();
  const giantScale = getGiantVisualScale();
  if (giantScale !== 1) {
    const pivotX = dog.x + dog.width * DOG_SPRITE_ANCHOR;
    const pivotY = GROUND_Y + 24;

    // Golden glow: draw the dog sprite slightly larger with shadowBlur behind the real sprite
    if (giantActive || giantShrinking) {
      const glowAlpha = giantShrinking ? Math.max(0, 1 - (performance.now() - giantTransitionStart) / GIANT_SCALE_TRANSITION) : 1;
      const remaining = GIANT_DURATION - (performance.now() - giantStartTime);
      const flash = (giantActive && remaining < GIANT_WARN_AT) ? (Math.sin(performance.now() * 0.015) > 0 ? 1 : 0.3) : 1;
      const glowPulse = 0.85 + 0.15 * Math.sin(performance.now() * 0.004);
      const glowScale = giantScale * (1 + 0.06 * glowPulse);
      ctx.save();
      ctx.translate(pivotX, pivotY);
      ctx.scale(glowScale, glowScale);
      ctx.translate(-pivotX, -pivotY);
      ctx.globalAlpha = 0.45 * glowAlpha * flash * glowPulse;
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 28;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      drawDachshund(dog.x, dog.y, dog.legFrame);
      ctx.restore();
    }

    // Draw the actual giant dog on top
    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.scale(giantScale, giantScale);
    ctx.translate(-pivotX, -pivotY);
    drawDachshund(dog.x, dog.y, dog.legFrame);
    ctx.restore();
  } else {
    drawDachshund(dog.x, dog.y, dog.legFrame);
  }

  // Draw chomp effects (CHOMP! text + crumb particles)
  giantChompEffects.forEach(e => {
    const age = (performance.now() - e.startTime) / 500;
    if (age > 1) return;
    ctx.save();
    ctx.globalAlpha = 1 - age;
    ctx.fillStyle = '#FFD700';
    ctx.font = `bold ${14 + age * 8}px Courier New`;
    ctx.textAlign = 'center';
    ctx.fillText('CHOMP!', e.x + 18, e.y - 10 - age * 20);
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2 + age * 2;
      const dist = age * 20;
      ctx.fillStyle = ['#D4951A', '#D94438', '#F5D000'][i % 3];
      ctx.beginPath();
      ctx.arc(e.x + 18 + Math.cos(angle) * dist, e.y + 11 + Math.sin(angle) * dist, 2 - age, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  });

  // Draw bonked frisbees flying away
  giantBonkEffects.forEach(e => {
    const age = (performance.now() - e.startTime) / 1500;
    if (age > 1) return;
    ctx.save();
    ctx.globalAlpha = 1 - age * 0.7;
    ctx.translate(e.x + 22, e.y + 7);
    ctx.rotate(e.rotation);
    ctx.translate(-(e.x + 22), -(e.y + 7));
    drawFrisbee(e.x, e.y);
    ctx.restore();
    if (age < 0.4) {
      ctx.save();
      ctx.globalAlpha = 1 - age / 0.4;
      ctx.fillStyle = '#FF69B4';
      ctx.font = `bold ${12 + age * 15}px Courier New`;
      ctx.textAlign = 'center';
      ctx.fillText('BONK!', e.x + 22, e.y - 15 - age * 30);
      ctx.restore();
    }
  });

  // Landing dust particles (tiny rainbow burst)
  landingParticles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = `hsla(${p.hue}, 85%, 65%, 0.9)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 1.5 + (1 - p.life) * 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });

  drawScore();
  drawMusicIcon();

  if (gameState === 'idle') {
    // Periodic global score refresh
    if (Date.now() - lastGlobalFetchTime > GLOBAL_FETCH_INTERVAL) {
      lastGlobalFetchTime = Date.now();
      fetchGlobalScores();
    }
    // Text background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    roundRect(W / 2 - 160, 58, 320, 40, 8);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('Press SPACE to start!', W / 2, 84);
    drawLocalLeaderboard(108);
  }

  if (gameState === 'dead' || gameState === 'enteringName') {
    // Text background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    roundRect(W / 2 - 150, 38, 300, 70, 8);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, 65);
    ctx.font = '16px Courier New';
    ctx.fillText('Press SPACE to restart', W / 2, 93);

    // Draw a little dizzy effect (X eyes on new head position)
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(dog.x + 82, dog.y - 5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#e02020';
    ctx.font = 'bold 7px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('X', dog.x + 82, dog.y - 3);
    drawLocalLeaderboard(118);
  }

  ctx.restore();
}

let lastFrameTime = 0;
function gameLoop(now) {
  now = now ?? performance.now();
  const dt = lastFrameTime ? Math.min(now - lastFrameTime, 100) : 16.67;
  lastFrameTime = now;
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

function showNameEntryOverlay() {
  const overlay = document.getElementById('nameEntryOverlay');
  const input = document.getElementById('nameInput');
  overlay.classList.add('visible');
  input.value = '';
  input.focus();
}

function hideNameEntryOverlay() {
  document.getElementById('nameEntryOverlay').classList.remove('visible');
}

function submitNameEntry() {
  if (gameState !== 'enteringName' || pendingScore == null) return;
  const name = document.getElementById('nameInput').value;
  addToHighScores(name, pendingScore);
  pendingScore = null;
  gameState = 'dead';
  hideNameEntryOverlay();
}

// --- Input ---
document.addEventListener('keydown', e => {
  if (gameState === 'enteringName') {
    if (e.code === 'Enter') {
      e.preventDefault();
      submitNameEntry();
    }
    return;
  }
  // Don't capture keys when typing in the search box
  if (document.activeElement && document.activeElement.id === 'lbSearch') return;
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    jump();
  }
  if (e.code === 'ArrowDown' || e.code === 'KeyS') {
    e.preventDefault();
    duck(true);
  }
  if (e.code === 'KeyP') {
    e.preventDefault();
    slowMode = !slowMode;
  }
  // Debug: C = trigger squirrel chase (when running)
  if (e.code === 'KeyC' && gameState === 'running' && !chaseActive && !chaseEntering && !chaseEscaping) {
    e.preventDefault();
    chasePending = true;
    obstacles = [];  // clear obstacles so chase starts immediately
  }
  // Debug: B = trigger boss chase (when running)
  if (e.code === 'KeyB' && gameState === 'running' && !bossChasing && !bossLosing) {
    e.preventDefault();
    bossPending = true;
    obstacles = [];  // clear obstacles so boss starts immediately
  }
  if (e.code === 'KeyG' && gameState === 'running' && !giantActive) {
    e.preventDefault();
    obstacles.push({
      x: dog.x + 120,
      y: GROUND_Y + 4,
      width: 36,
      height: 22,
      type: 'golden',
    });
  }
});

document.addEventListener('keyup', e => {
  if (document.activeElement && document.activeElement.id === 'lbSearch') return;
  if (e.code === 'ArrowDown' || e.code === 'KeyS') {
    duck(false);
  }
});

function getLogicalCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = ('touches' in e ? e.touches[0].clientX : e.clientX);
  const cy = ('touches' in e ? e.touches[0].clientY : e.clientY);
  return {
    x: (cx - rect.left) / rect.width * W,
    y: (cy - rect.top) / rect.height * H,
  };
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const p = getLogicalCoords(e);
  if (p.x < 38 && p.y < 32) { toggleMusic(); return; }
  jump();
});

canvas.addEventListener('click', e => {
  const p = getLogicalCoords(e);
  if (p.x < 38 && p.y < 32) { toggleMusic(); return; }
  jump();
});

document.getElementById('nameSubmitBtn').addEventListener('click', submitNameEntry);

// --- Global leaderboard controls ---
document.getElementById('lbSearch').addEventListener('input', e => {
  lbSearchTerm = e.target.value.trim();
  lbPage = 0;
  renderHtmlLeaderboard();
});
document.getElementById('lbPrev').addEventListener('click', () => {
  if (lbPage > 0) { lbPage--; renderHtmlLeaderboard(); }
});
document.getElementById('lbNext').addEventListener('click', () => {
  const filtered = getFilteredScores();
  const totalPages = Math.ceil(filtered.length / GLOBAL_PAGE_SIZE);
  if (lbPage < totalPages - 1) { lbPage++; renderHtmlLeaderboard(); }
});

// --- Start ---
highScores = loadHighScores();
highScore = highScores[0]?.score ?? 0;
renderHtmlLeaderboard();
fetchGlobalScores();
gameLoop();
</script>
</body>
</html>
